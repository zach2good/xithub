# xithub

A central repository for FFXI packet data.

## TODO Before Use

- Use TCP instead of UDP?
- Make sure we use the same compression everywhere (GZip, zlib, ZipFile, etc. - It'll be gzip everywhere).
- Handle both S2C and C2S packets.
- Timed fallback for sending buffer from client.
- Forced send from client on logout.
- Do not archive packets that are part of a currently-ongoing session.
- Cut session if character name changes (logging into alts), but session should be cut automatically on logout.
- A final stage of processing to happen when a session is closed.
- Address all leftover TODOs
- OAuth (Google only) authentication flow, server + client
- Premade/cached lookups per session (generated during processing):
  - Events + Args
  - Mobs spawned
  - Estimate mob HP
- Closed testing
- Write up terms and conditions - you won't be allowed to revoke your packet data!
- GDPR, User Data, Safety
- Host server somewhere in GCP

## Long Term

- Allow users to look up their sessions and add links to videos to them
  - Would be lovely to embed them too (but not host!).
- Allow users to download their session packet data, in multiple formats (PacketViewer, Binary, etc.)
- Archive to GCP's Cold Storage equivalent
- AH data?
- What if it gets expensive to run/maintain?

## Packet Binary Format

```cpp
#pragma pack(push, 1)
struct OuterPacketHeader
{
    uint64_t userId;
    uint64_t timestamp;
    uint8_t  serverId;
    char     characterName[15];
    uint32_t dataSize;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct InnerPacketHeader
{
    uint64_t timestamp;
    uint16_t zoneId;
    uint32_t dataSize;
};
#pragma pack(pop)

// A packet will be recieved and stored as:

OuterPacketHeader + GZipData

// `GZipData` is a gzip'd block of the following layout:

InnerPacketHeader + Data + InnerPacketHeader + Data + ...

// In all cases you'll need to unpack the header to get `dataSize` so you
// can handle whatever the next stage is.
```

## Packet DB Schema

Client: The FFXI Client and Plugin
Server: The xithub packet process

```
[row_id, user_id, session_id, character_name, zone_id, server_timestamp, client_timestamp, packet_id, raw_data]
```

- RowId: Autoincremented Row ID
- UserId: The website-generated ID of the submitting user, we'll match the incoming IP with this to make sure they match
- SessionId: Generated by us: We'll cut sessions after 5 minutes of inactivity. We'll make session cuts requestable by users in the future.
- CharacterName: The logged in character's name.
- ServerId: The retail server the character is on.
- ZoneId: The zone of the logged in character.
- ServerTimestamp: When the server recieved this packet in a collection with other packets
- ClientTimestamp: When the client recieved or sent this packet and it was copied for us to use for our purposes.
- PacketId: The 9-byte ID of the packet.
- RawData: A BLOB of the original packet.

## Client

`/client/ashita` and `/client/windower/`

Ashita-v4 and Windower-v4 plugins which non-intrusively collects and sends all packet data to the cloud.

### Usage (Ashita-v4)

...

### Usage (Windower-v4)

...

### NOTES

- The pre-compiled DLL may be flagged by your antivirus. This is a false positive, sorry! If you're unsure about the DLL, feel free to poke around in the code and to build it locally.
- Nothing bad will happen if you use this (or leave it on) while playing on private servers, the plugin will just be idle and not collect or send any information.

### Thanks

- atom0s([Ashita-v4beta](https://github.com/AshitaXI/Ashita-v4beta), [ExamplePlugin](https://github.com/AshitaXI/ExamplePlugin))
- Heals ([XIPivot](https://github.com/Shirk/XIPivot))
- Windower Team ([Website](https://www.windower.net/), [GitHub](https://github.com/Windower))

## Server

`/server`

TODO

`/server/docker-compose.yml`

TODO

`/server/frontend`

TODO

`/server/backend`

TODO

## Hosting

...
